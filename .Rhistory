for (i in 1:ncol(combination_S)) {
vertex_1 <- Span_S[, combination_S[1, i]]
vertex_2 <- Span_S[, combination_S[2, i]]
for (j in 1:length(border_M)) {
n1 <- sum(vertex_1 * border_M[[j]])
n2 <- sum(vertex_2 * border_M[[j]])
auxi <- n1 * n2
if (auxi < -1e-10) {
lambda <- n2 / (n2 - n1)
possible <- lambda * vertex_1 + (1 - lambda) * vertex_2
if (det(extreme_point_M[[j]]) != 0) {
auxi2 <- inside_face_detection(extreme_point_M[[j]], possible[1:(num - 1)])
if (auxi2 == 1) {
intersection_vertex[[l]] <- possible
side[l] <- j
l <- l + 1
}
}
}
}
}
if (length(intersection_vertex) > 0) {
for (i in 1:length(intersection_vertex)) {
intersection_vertex[[i]] <- normalize(intersection_vertex[[i]])
}
}
return(intersection_vertex)
}
# function that computes all the extreme points
# inputs: A = one interaction matrix, B = another interaction matrix
# output: out = all the extreme points that generate the intersection region
vertex_detection <- function(A, B) {
num <- ncol(A)
inside_vertex <- inside_vertex_detection(A, B)
intersection_vertex <- intersection_vertex_detection(A, B)
# combine the two vertex lists
if (length(inside_vertex) > 0) {
vertex <- matrix(unlist(inside_vertex), nrow = num, byrow = FALSE)
} else {
vertex <- matrix(0, nrow = num, ncol = 2)
}
if (length(intersection_vertex) > 0) {
vertex <- cbind(vertex, matrix(unlist(intersection_vertex), nrow = num, byrow = FALSE))
}
# delete the points that are nonzero due to numerical error
delete_zeroes <- c()
for (i in 1:ncol(vertex)) {
if (near(sum(vertex[, i]^2), 0)) {
delete_zeroes <- c(delete_zeroes, i)
}
}
if (length(delete_zeroes) > 0) vertex <- vertex[, -delete_zeroes]
# delete the same ones
if (length(vertex) > num) {
for (test in 1:ncol(vertex)) {
vertex[, test] <- normalize(vertex[, test])
}
delete_duplicates <- c()
for (i in 1:(ncol(vertex) - 1)) {
for (j in (i + 1):ncol(vertex)) {
if (sum(near(vertex[, i], vertex[, j])) == nrow(vertex)) {
delete_duplicates <- c(delete_duplicates, j)
}
}
}
if (length(delete_duplicates) > 0) vertex <- vertex[, -unique(delete_duplicates)]
}
return(vertex)
}
# function that computes the full volume
# inputs: partition = triangulation of the intersection region, vertex = all the extreme points
# output: the normalize feasibility of the intersection region
calculate_total_volume <- function(vertex) {
num <- nrow(vertex)
vertex <- cbind(vertex, rep(0, num))
(convhulln(t(vertex), output.options = TRUE)$vol)^(1/num)
}
# function that computes the overlap of two feasibility domains
# inputs: A = one interaction matrix, B = another interaction matrix
# output: volume_overlap = the normalize feasibility of the intersection region
calculate_omega_overlap <- function(A, B) {
num <- nrow(A)
overlap_vertex <- cbind(vertex_detection(A, B), vertex_detection(A, B))
vertex_detection(B, A)
if (qr(overlap_vertex)$rank < num) {
volume_overlap <- 0
} else {
volume_overlap <- calculate_total_volume(overlap_vertex)
}
volume_overlap
}
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
Omega(A)
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 3
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
set.seed(3)
A <- interaction_matrix_random(num, stren, conne) #generate a random interaction matrix
I1 <- c(1, 2, -1, 1) #put a linear inequality contraint. The interpretation is 1*r1 + 2*r2 - r3 + r4 = 1
I2 <- c(1, 2, 0, 0) #put a linear inequality contraint. The interpretation is 1*r1 + 2*r2 = 1
set.seed(3)
A <- interaction_matrix_random(num, stren, conne) #generate a random interaction matrix
I1 <- c(1, 2, -1, 1) #put a linear inequality contraint. The interpretation is 1*r1 + 2*r2 - r3 + r4 = 1
I2 <- c(1, 2, 0, 0) #put a linear inequality contraint. The interpretation is 1*r1 + 2*r2 = 1
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, I1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
set.seed(4)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
set.seed(4)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, C1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
calculate_omega_overlap(A, C2) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I2
set.seed(4)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, C1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
calculate_omega_overlap(A, C2) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I2
use_package(mvtnorm, type = "Imports")
library(devtools)
use_package(mvtnorm, type = "Imports")
use_package("mvtnorm", type = "Imports")
use_package("mgcv", type = "Imports")
use_package("geometry", type = "Imports")
use_package("dplyr", type = "Imports")
use_package("
tidyr", type = "Imports")
use_package("tidyr", type = "Imports")
use_package("purrr", type = "Imports")
use_pipe()
use_tibble()
use_test(name = "test")
library(feasoverlap)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
set.seed(4)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, C1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
calculate_omega_overlap(A, C2) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I2
set.seed(40)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, C1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
calculate_omega_overlap(A, C2) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I2
set.seed(10)
A <- interaction_matrix_random(3, 0.4, 1) #generate a random interaction matrix
C1 <- diag(c(-1,-1,-1), 3) #imposing a biological constraint. Here it refers to that the growth rates of all species have to be positive
C2 <- diag(c(1,-1,1), 3)  #imposing a biological constraint. Here it refers to that the growth rates of species 1 and 3 have to be negative, and the growth rates of species 2 has to be positive
calculate_omega(A) #relative size of the original interaction matrix
calculate_omega_overlap(A, C1) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I1
calculate_omega_overlap(A, C2) #the size of the feasibility domain of a random interaction matrix under linear biological constriants I2
use_rmarkdown_template()
use_readme_rmd()
build_readme()
library(feasoverlap)
#set the parameter for the data
num = 4
stren = 0.4
conne = 1
#generate two random interaction matrices
set.seed(1)
A <- interaction_matrix_random(num, stren, conne)
set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega(A) #relative size of interaction matrix
calculate_omega(B) #relative size of interaction matrix
calculate_omega_overlap(A, B) #overlap of two interaction matrices
build_readme()
calculate_omega_overlap(A, A)
calculate_omega_overlap(A, A)
calculate_omega_overlap(A, B)
calculate_total_volume(A)
calculate_total_volume(B)
calculate_omega_overlap(B,B)
calculate_total_volume(B)
library(feasoverlap)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_total_volume(A)
calculate_total_volume(B)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
calculate_omega_overlap(B,B)
calculate_omega(B)
calculate_omega_overlap(B,B)
calculate_omega(B)
calculate_omega_overlap(B,B)
library(feasoverlap)
num = 5
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(10)
A <- interaction_matrix_random(num, stren, conne)
# set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
calculate_omega_overlap(A, B)
calculate_omega(A)
calculate_omega(B)
calculate_omega_overlap(B,B)
library(feasoverlap)
library(feasoverlap)
styler:::style_active_file()
library(feasoverlap)
#set the parameter for the data
num = 4
stren = 0.4
conne = 1
#generate two random interaction matrices
set.seed(1)
A <- interaction_matrix_random(num, stren, conne)
vertex <- interaction_matrix_random(num, stren, conne)
num <- nrow(vertex)
vertex <- generate_span_vectors(vertex)
vertex <- cbind(vertex, rep(0, num))
(convhulln(t(vertex), output.options = TRUE)$vol)^(1/num)
num <- nrow(vertex)
vertex <- generate_span_vectors(vertex)
vertex <- cbind(vertex, rep(0, num))
convhulln(t(vertex)
convhulln(t(vertex))
convhulln(t(vertex))
library(geometry)
convhulln(t(vertex))
convhulln
vertex
num <- nrow(vertex)
vertex <- generate_span_vectors(vertex)
vertex <- cbind(vertex, rep(0, num))
vertex
#generate two random interaction matrices
set.seed(1)
vertex <- interaction_matrix_random(num, stren, conne)
num <- nrow(vertex)
vertex <- generate_span_vectors(vertex)
vertex <- cbind(vertex, rep(0, num))
vertex
convhulln(t(vertex))
feasible.point((t(vertex))
c
feasible.point((t(vertex)))
feasible.point(convhulln(t(vertex)))
convhulln(t(vertex))
feasible.point(convhulln(t(vertex)))
feasible.point(convhulln(t(vertex)), convhulln(t(vertex)))
vertex
library(uniformly)
runif_on_sphere(n = 100, d = num, r = 1)
abs(runif_on_sphere(n = 100, d = num, r = 1))
vertex
vertex <- interaction_matrix_random(num, stren, conne)
vertex
#set the parameter for the data
num = 4
stren = 0.4
conne = 1
#generate two random interaction matrices
# set.seed(1)
vertex <- interaction_matrix_random(num, stren, conne)
set.seed(1)
A <- interaction_matrix_random(num, stren, conne)
set.seed(2)
B <- interaction_matrix_random(num, stren, conne)
overlap_vertex <- cbind(vertex_detection(A, B), vertex_detection(A, B))
vertex <- cbind(vertex_detection(A, B), vertex_detection(A, B))
num <- nrow(vertex)
vertex
abs(runif_on_sphere(n = 100, d = num, r = 1)) %*% vertex
abs(runif_on_sphere(n = 5, d = num, r = 1)) %*% vertex
vertex
vertex
vertex <- cbind(vertex_detection(A, B), vertex_detection(B, A))
vertex
library(feasoverlap)
abs(runif_on_sphere(n = 5, d = ncol(vertex), r = 1)) %*% vertex
vertex %*% abs(runif_on_sphere(n = 5, d = ncol(vertex), r = 1))
vertex
abs(runif_on_sphere(n = 5, d = ncol(vertex), r = 1))
vertex %*% t(abs(runif_on_sphere(n = 5, d = ncol(vertex), r = 1)))
vertex %*% t(abs(runif_on_sphere(n = 20, d = ncol(vertex), r = 1)))
styler:::style_active_file()
use_package(uniformly)
use_package("uniformly")
library(feasoverlap)
library(feasoverlap)
library(feasoverlap)
# generate two random interaction matrices
set.seed(1)
A <- interaction_matrix_random(num = 4, stren = 0.4, conne = 1)
set.seed(2)
B <- interaction_matrix_random(num = 4, stren = 0.4, conne = 1)
calculate_omega(A) # relative size of interaction matrix
num <- nrow(A)
overlap_vertex <- vertex_detection(A, B) %>%
cbind(vertex_detection(B, A)) %>%
unique(MARGIN = 2)
vertex_detection(B, A)
if (qr(overlap_vertex)$rank < num) {
volume_overlap <- 0
} else {
volume_overlap <- calculate_omega(overlap_vertex, samples)
}
samples = 100
volume_overlap <- calculate_omega(overlap_vertex, samples)
volume_overlap
library(feasoverlap)
